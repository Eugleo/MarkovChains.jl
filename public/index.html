<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Veřejné symboly (EN) · MarkovChains.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="MarkovChains.jl logo"/></a><h1>MarkovChains.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Domovská stránka</a></li><li><span class="toctext">Vysvětlení</span><ul><li><a class="toctext" href="../function/">Princip</a></li><li><a class="toctext" href="../implementation/">Implementace</a></li></ul></li><li><span class="toctext">Příklady</span><ul><li><a class="toctext" href="../lipsum/">Lorem ipsum</a></li></ul></li><li><span class="toctext">Knihovna</span><ul><li class="current"><a class="toctext" href>Veřejné symboly (EN)</a><ul class="internal"><li><a class="toctext" href="#pub_markov-1">Module MarkovChains</a></li><li><a class="toctext" href="#pub_tokenizer-1">Module Tokenizer</a></li></ul></li><li><a class="toctext" href="../internals/">Interní symboly (EN)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Knihovna</li><li><a href>Veřejné symboly (EN)</a></li></ul><a class="edit-page" href="https://github.com/Eugleo/MarkovChains.jl/blob/master/docs/src/public.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Veřejné symboly (EN)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-Documentation-1" href="#Public-Documentation-1">Public Documentation</a></h1><h2><a class="nav-anchor" id="pub_markov-1" href="#pub_markov-1">Module MarkovChains</a></h2><p>The following is the documentation of symbols which are exported from the <code>MarkovChains</code> module. The module is used to construct a Markov chain from the given list of lists of tokens and to walk through it, generating a random sequence of tokens along the way. Please see Příklady if you are looking for some usage examples.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.Model" href="#MarkovChains.Model"><code>MarkovChains.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The datastructure of the Markov chain. Encodes all the different states and the probabilities of going from one to another as a dictionary. The keys are the states, the values are the respective <a href="../internals/#MarkovChains.TokenOccurences"><code>TokenOccurences</code></a> dictionaries. Those are dictionaries which say how many times was a token found <em>immediately</em> after the state.</p><p><strong>Fields</strong></p><ul><li><code>order</code> is the number of tokens in a <a href="../internals/#MarkovChains.State"><code>State</code></a></li><li><code>nodes</code> is a dictionary pairing <a href="../internals/#MarkovChains.State"><code>State</code></a> and its respective</li></ul><p><a href="../internals/#MarkovChains.TokenOccurences"><code>TokenOccurences</code></a> dictionary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/MarkovChains.jl#L28-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.Model-Tuple{Any}" href="#MarkovChains.Model-Tuple{Any}"><code>MarkovChains.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Model(nodes)</code></pre><p>Return a model constructed from <code>nodes</code>. Can be used to reconstruct a model object from its nodes, e.g. if the nodes were saved in a JSON file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/MarkovChains.jl#L56-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.Model-Union{Tuple{Array{#s18,1} where #s18&lt;:Array{T,1}}, Tuple{T}} where T" href="#MarkovChains.Model-Union{Tuple{Array{#s18,1} where #s18&lt;:Array{T,1}}, Tuple{T}} where T"><code>MarkovChains.Model</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Model(suptokens::Vector{&lt;:Vector{T}}; order=2, weight=stdweight)</code></pre><p>Return a <a href="#MarkovChains.Model"><code>Model</code></a> trained on an array of arrays of <a href="../internals/#MarkovChains.Token"><code>tokens</code></a> (<code>suptokens</code>). Optionally an <code>order</code> of the chain can be supplied; that is the number of tokens in one state. A weight function of general type <code>func(::State{T}, ::Token{T}) -&gt; Int</code> can be supplied to be used to bias the weights based on the state or token value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/MarkovChains.jl#L88-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.combine-Tuple{Any,Vararg{Any,N} where N}" href="#MarkovChains.combine-Tuple{Any,Vararg{Any,N} where N}"><code>MarkovChains.combine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">combine(chain, others)</code></pre><p>Return a Model which is a combination of all of the models provided. All of the arguments should have the same <code>order</code>. The nodes of all the Models are merged using the function <code>merge</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/MarkovChains.jl#L45-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk-Tuple{Any}" href="#MarkovChains.walk-Tuple{Any}"><code>MarkovChains.walk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk(model[, init_state])</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. The walk starts at state <code>init_state</code> if supplied, and at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) otherwise. The walk ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk2-Tuple{Any}"><code>walk2</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/MarkovChains.jl#L119-L129">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk2-Tuple{Any}" href="#MarkovChains.walk2-Tuple{Any}"><code>MarkovChains.walk2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk2(model[, init_state])</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. When there is only one state following the current one (i.e. there is 100% chance that the state will become the next one), the function shortens the current <code>State</code> as to lower the requirements and obtain more randomness. The <code>State</code> gets shortened until a state with at least two possible successors is found (or until <code>State</code> is only one token long).</p><p>The walk starts at state <code>init_state</code> if supplied, and at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) otherwise. The walk ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk-Tuple{Any}"><code>walk</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/MarkovChains.jl#L165-L180">source</a></section><h2><a class="nav-anchor" id="pub_tokenizer-1" href="#pub_tokenizer-1">Module Tokenizer</a></h2><p>The following symbols are exported from the <code>Tokenizer</code> module. This module is used to tokenize text into a list of lists of tokens, which is a format better suited for model training.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.cleanup-Tuple{Array{#s19,1} where #s19&lt;:(Array{#s20,1} where #s20&lt;:AbstractString)}" href="#Tokenizer.cleanup-Tuple{Array{#s19,1} where #s19&lt;:(Array{#s20,1} where #s20&lt;:AbstractString)}"><code>Tokenizer.cleanup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cleanup(suptokens::Vector{&lt;:Vector{&lt;:AbstractString}}; badchars=&quot;»«\n-_()[]{}&lt;&gt;–—$=&#39;&quot;„“	&quot;)</code></pre><p>Remove all characters that are in <code>badchars</code> from all tokens in <code>suptokens</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L74-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.letters" href="#Tokenizer.letters"><code>Tokenizer.letters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">letters = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into sentences, then the sentences into letters, and then removes special characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L90-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.lines" href="#Tokenizer.lines"><code>Tokenizer.lines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lines = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into lines, then the line into letters, and then removes special characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L98-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_letters-Tuple{Array{#s12,1} where #s12&lt;:AbstractString}" href="#Tokenizer.to_letters-Tuple{Array{#s12,1} where #s12&lt;:AbstractString}"><code>Tokenizer.to_letters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_letters(tokens::Vector{&lt;:AbstractString})</code></pre><p>Split all of the tokens in <code>tokens</code> into individual characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L53-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_lines-Tuple{AbstractString}" href="#Tokenizer.to_lines-Tuple{AbstractString}"><code>Tokenizer.to_lines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_lines(text::AbstractString)</code></pre><p>Return an array of lines in <code>text</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_sentences-Tuple{AbstractString}" href="#Tokenizer.to_sentences-Tuple{AbstractString}"><code>Tokenizer.to_sentences</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_sentences(text::AbstractString)</code></pre><p>Return an array of sentences in <code>text</code>. The text is split along dots; the dots remain in the strings, only the spaces after the dots are stripped.</p><p>The function tries to be as smart as possible. For example, the string <code>&quot;Channel No. 5 is a perfume.&quot;</code> will be treated as one sentence, although it has two dots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L36-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.tokenize-Tuple{Any}" href="#Tokenizer.tokenize-Tuple{Any}"><code>Tokenizer.tokenize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tokenize(text[, on=letters])</code></pre><p>Split <code>text</code> into SupTokens (array of arrays of tokens). An optional function of general type <code>func(::Any) -&gt; Vector{Vector{Any}}</code> can be provided to be used for the tokenization.</p><p>For possible <em>combinators</em> which can be composed to obtain <code>func</code>, see: <a href="#Tokenizer.to_lines-Tuple{AbstractString}"><code>to_lines</code></a>, <a href="#Tokenizer.to_sentences-Tuple{AbstractString}"><code>to_sentences</code></a>, <a href="#Tokenizer.to_letters-Tuple{Array{#s12,1} where #s12&lt;:AbstractString}"><code>to_letters</code></a>, <a href="../internals/#Tokenizer.to_words-Tuple{Array{#s16,1} where #s16&lt;:AbstractString}"><code>to_words</code></a>, <a href="#Tokenizer.cleanup-Tuple{Array{#s19,1} where #s19&lt;:(Array{#s20,1} where #s20&lt;:AbstractString)}"><code>cleanup</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L12-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.words" href="#Tokenizer.words"><code>Tokenizer.words</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">words = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into sentences, then the sentences into words, and then removes special characters. Please note that dots and commas are not removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d9bfc4b86ba73785855fa7e93534c52bce68e5fd/src/Tokenizer.jl#L106-L112">source</a></section><footer><hr/><a class="previous" href="../lipsum/"><span class="direction">Previous</span><span class="title">Lorem ipsum</span></a><a class="next" href="../internals/"><span class="direction">Next</span><span class="title">Interní symboly (EN)</span></a></footer></article></body></html>
