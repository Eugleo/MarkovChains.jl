<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Veřejné symboly (EN) · MarkovChains.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="MarkovChains.jl logo"/></a><h1>MarkovChains.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Domovská stránka</a></li><li><span class="toctext">Vysvětlení</span><ul><li><a class="toctext" href="../function/">Princip</a></li><li><a class="toctext" href="../implementation/">Implementace</a></li></ul></li><li><span class="toctext">Příklady</span><ul><li><a class="toctext" href="../lipsum/">Lorem ipsum</a></li></ul></li><li><span class="toctext">Knihovna</span><ul><li class="current"><a class="toctext" href>Veřejné symboly (EN)</a><ul class="internal"><li><a class="toctext" href="#Module-MarkovChains-1">Module MarkovChains</a></li><li><a class="toctext" href="#pub_tokenizer-1">Module Tokenizer</a></li></ul></li><li><a class="toctext" href="../internals/">Interní symboly (EN)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Knihovna</li><li><a href>Veřejné symboly (EN)</a></li></ul><a class="edit-page" href="https://github.com/Eugleo/MarkovChains.jl/blob/master/docs/src/public.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Veřejné symboly (EN)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-Documentation-1" href="#Public-Documentation-1">Public Documentation</a></h1><h2><a class="nav-anchor" id="Module-MarkovChains-1" href="#Module-MarkovChains-1">Module MarkovChains</a></h2><p>The following is the documentation of symbols which are exported from the <code>MarkovChains</code> module. The module is used to construct a Markov chain from the given list of lists of tokens and to walk through it, generating a random sequence of tokens along the way. Please see Příklady if you are looking for some usage examples.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.build-Union{Tuple{Array{#s18,1} where #s18&lt;:Array{T,1}}, Tuple{T}} where T" href="#MarkovChains.build-Union{Tuple{Array{#s18,1} where #s18&lt;:Array{T,1}}, Tuple{T}} where T"><code>MarkovChains.build</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">build(suptokens; order=2, weight=stdweight)</code></pre><p>Trains a Markov chain on an array of arrays of tokens (suptokens). Optionally an <code>order</code> of the chain can be supplied, that is the number of tokens in one state. A weight function of general type <code>func(::State{T}, ::Token{T})::Int</code> can be supplied to be used to bias the weights based on the state or token.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/MarkovChains.jl#L89-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.combine-Union{Tuple{T}, Tuple{Any,Vararg{Any,N} where N}} where T" href="#MarkovChains.combine-Union{Tuple{T}, Tuple{Any,Vararg{Any,N} where N}} where T"><code>MarkovChains.combine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">combine(chain, others)</code></pre><p>Return a Model which is a combination of all of the models provided. All of the arguments should have the same <code>order</code>. The nodes of all the Models are merged using the function <code>merge</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/MarkovChains.jl#L45-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.makefromdict-Tuple{Any}" href="#MarkovChains.makefromdict-Tuple{Any}"><code>MarkovChains.makefromdict</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">makefromdict(nodes)</code></pre><p>Return a model constructed from the given nodes. Can be used to reconstruct a model object from its nodes, e.g. if the nodes were saved in a JSON file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/MarkovChains.jl#L57-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.state_with_beginning-Tuple{Any,Any}" href="#MarkovChains.state_with_beginning-Tuple{Any,Any}"><code>MarkovChains.state_with_beginning</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">state_with_beginning(model, tokens; strict=false)</code></pre><p>Attempts to return a random valid state of <code>model</code> that begins with <code>tokens</code>. If <code>strict</code> is <code>false</code> and the <code>model</code> doesn&#39;t have any state that begins with <code>tokens</code>, the function shortens the tokens (cuts the last token) to lower the requirements and tries to find some valid state again.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/MarkovChains.jl#L237-L244">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk-Tuple{Any}" href="#MarkovChains.walk-Tuple{Any}"><code>MarkovChains.walk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk(model[, init_state])</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. The walk starts at state <code>init_state</code> if supplied, and at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) otherwise. The walk ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk2-Tuple{Any}"><code>walk2</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/MarkovChains.jl#L120-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk2-Tuple{Any}" href="#MarkovChains.walk2-Tuple{Any}"><code>MarkovChains.walk2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk2(model[, init_state])</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. When there is only one state following the current one (i.e. there is 100% chance that the state will become the next one), the function shortens the current <code>State</code> as to lower the requirements and obtain more randomness. The <code>State</code> gets shortened until a state with at least two possible successors is found (or until <code>State</code> is only one token long).</p><p>The walk starts at state <code>init_state</code> if supplied, and at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) otherwise. The walk ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk-Tuple{Any}"><code>walk</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/MarkovChains.jl#L166-L181">source</a></section><h2><a class="nav-anchor" id="pub_tokenizer-1" href="#pub_tokenizer-1">Module Tokenizer</a></h2><p>The following symbols are exported from the <code>Tokenizer</code> module. This module is used to tokenize text into a list of lists of tokens, which is a format better suited for model training.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.cleanup-Tuple{Array{#s19,1} where #s19&lt;:(Array{#s20,1} where #s20&lt;:AbstractString)}" href="#Tokenizer.cleanup-Tuple{Array{#s19,1} where #s19&lt;:(Array{#s20,1} where #s20&lt;:AbstractString)}"><code>Tokenizer.cleanup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cleanup(suptokens::Vector{&lt;:Vector{&lt;:AbstractString}}; badchars=&quot;\n-_()[]{}&lt;&gt;–—$=&#39;&quot;„“	&quot;)</code></pre><p>Remove all characters that are in <code>badchars</code> from all tokens in <code>suptokens</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L74-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.letters" href="#Tokenizer.letters"><code>Tokenizer.letters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">letters = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into sentences, then the sentences into letters, and then removes special characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L90-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.lines" href="#Tokenizer.lines"><code>Tokenizer.lines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lines = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into lines, then the line into letters, and then removes special characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L98-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_letters-Tuple{Array{#s13,1} where #s13&lt;:AbstractString}" href="#Tokenizer.to_letters-Tuple{Array{#s13,1} where #s13&lt;:AbstractString}"><code>Tokenizer.to_letters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_letters(tokens::Vector{&lt;:AbstractString})</code></pre><p>Split all of the tokens in <code>tokens</code> into individual characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L53-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_lines-Tuple{AbstractString}" href="#Tokenizer.to_lines-Tuple{AbstractString}"><code>Tokenizer.to_lines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_lines(text::AbstractString)</code></pre><p>Return an array of lines in <code>text</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_sentences-Tuple{AbstractString}" href="#Tokenizer.to_sentences-Tuple{AbstractString}"><code>Tokenizer.to_sentences</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_sentences(text::AbstractString)</code></pre><p>Return an array of sentences in <code>text</code>. The text is split along dots; the dots remain in the strings, only the spaces after the dots are stripped.</p><p>The function tries to be as smart as possible. For example, the string <code>&quot;Channel No. 5 is a perfume.&quot;</code> will be treated as one sentence, although it has two dots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L36-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.tokenize" href="#Tokenizer.tokenize"><code>Tokenizer.tokenize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tokenize(inp[, func=letters])</code></pre><p>Split the text into SupTokens (list of lists of tokens). An optional function of general type <code>func(::Any)::Vector{Vector{Any}}</code> can be provided to be used for the tokenization.</p><p>For possible <em>combinators</em> which can be composed to obtain <code>func</code>, see: <a href="#Tokenizer.to_lines-Tuple{AbstractString}"><code>to_lines</code></a>, <a href="#Tokenizer.to_sentences-Tuple{AbstractString}"><code>to_sentences</code></a>, <a href="#Tokenizer.to_letters-Tuple{Array{#s13,1} where #s13&lt;:AbstractString}"><code>to_letters</code></a>, <a href="../internals/#Tokenizer.to_words-Tuple{Array{#s16,1} where #s16&lt;:AbstractString}"><code>to_words</code></a>, <a href="#Tokenizer.cleanup-Tuple{Array{#s19,1} where #s19&lt;:(Array{#s20,1} where #s20&lt;:AbstractString)}"><code>cleanup</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L12-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.words" href="#Tokenizer.words"><code>Tokenizer.words</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">words = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into sentences, then the sentences into words, and then removes special characters. Please note that dots and commas are not removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/d528dc0d2986cd3be635dbe047542a4c9dbebd13/src/Tokenizer.jl#L106-L112">source</a></section><footer><hr/><a class="previous" href="../lipsum/"><span class="direction">Previous</span><span class="title">Lorem ipsum</span></a><a class="next" href="../internals/"><span class="direction">Next</span><span class="title">Interní symboly (EN)</span></a></footer></article></body></html>
