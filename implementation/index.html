<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementace · MarkovChains.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="MarkovChains.jl logo"/></a><h1>MarkovChains.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Domovská stránka</a></li><li><span class="toctext">Vysvětlení</span><ul><li><a class="toctext" href="../function/">Princip</a></li><li class="current"><a class="toctext" href>Implementace</a><ul class="internal"><li><a class="toctext" href="#Rozložení-textu-na-tokeny-1">Rozložení textu na tokeny</a></li><li><a class="toctext" href="#Trénování-modelu-na-základě-tokenů-1">Trénování modelu na základě tokenů</a></li><li><a class="toctext" href="#Procházení-modelového-grafu-1">Procházení modelového grafu</a></li></ul></li></ul></li><li><span class="toctext">Příklady</span><ul><li><a class="toctext" href="../lipsum/">Lorem ipsum</a></li></ul></li><li><span class="toctext">Knihovna</span><ul><li><a class="toctext" href="../public/">Veřejné symboly (EN)</a></li><li><a class="toctext" href="../internals/">Interní symboly (EN)</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Vysvětlení</li><li><a href>Implementace</a></li></ul><a class="edit-page" href="https://github.com/Eugleo/MarkovChains.jl/blob/master/docs/src/implementation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Implementace</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Popis-implementace-1" href="#Popis-implementace-1">Popis implementace</a></h1><div class="admonition note"><div class="admonition-title">Poznámka</div><div class="admonition-text"><p>Tento text pojednává o konkrétní implementaci Markovova řetězce v tomto balíčku. Naopak obecnému principu se věnuje oddíl <a href="../function/#Popis-principu-funkce-1">Popis principu funkce</a>.</p></div></div><p>Generování textu se dá rozdělit na několik logických podcelků:</p><ol><li>Rozložení textu na tokeny.</li><li>Trénování modelu na základě tokenů.</li><li>Procházení modelového grafu.</li></ol><h2><a class="nav-anchor" id="Rozložení-textu-na-tokeny-1" href="#Rozložení-textu-na-tokeny-1">Rozložení textu na tokeny</a></h2><p>Text je před zpracováním nutno rozdělit na menší celky. Má konkrétní implementace modelu počítá s tím, že text bude rozložen na pole polí tokenů, například tedy: <code>PoleVět{PoleSlov{Slova/Tokeny}}</code>. K tomu slouží modul Tokenizer (dokumentace v oddílu <a href="../public/#pub_tokenizer-1">Public Documentation</a>), který nabízí několik jednoduchých &quot;kombinátorů&quot;, které může uživatel použít k rozdělení textu podle vět, řádků, slov a podobně. Jejich implementace není ničím zajímavá, jedná se o one-line funkce pracující na základě regexů.</p><h2><a class="nav-anchor" id="Trénování-modelu-na-základě-tokenů-1" href="#Trénování-modelu-na-základě-tokenů-1">Trénování modelu na základě tokenů</a></h2><p>Reprezentovat model grafem je zbytečně složité; hlavně implementačně, protože se jedná o rekurzivní datovou strukturu. Je proto vhodné převést tuto ústřední datovou strukturu na jinou, se kterou se v kódu lépe pracuje.</p><h3><a class="nav-anchor" id="Datové-struktury-1" href="#Datové-struktury-1">Datové struktury</a></h3><p>Pro zjednodušení je možné využít toho, že dva po sobě jdoucí stavy se liší pouze o jeden token. Celý graf pak jde převést na slovník párující vždy nějaký stav se všemi tokeny, které se po něm vyskytují.</p><p>Pokud zadefinuji pomocné datové struktury <code>State</code> a <code>TokenOccurences</code></p><pre><code class="language-julia">State{T} = Vector{Token{T}}
TokenOccurences{T} = Dict{Token{T}, Int}</code></pre><p>mohu graf/Markovův řetězec/model implementovat následovně</p><pre><code class="language-julia">struct Model{T}
    order::Int
    nodes::Dict{State{T}, TokenOccurences{T}}
end</code></pre><h3><a class="nav-anchor" id="Trénování-1" href="#Trénování-1">Trénování</a></h3><p>Vstupní tokeny je nutno zanalyzovat a vytvořit z nich <code>Model</code>. K tomu slouží funkce <a href="../public/#MarkovChains.build-Union{Tuple{Array{#s18,1} where #s18&lt;:Array{T,1}}, Tuple{T}} where T"><code>build</code></a>. Každý model má pevně určený řád (order), který je nutné funkci <a href="../public/#MarkovChains.build-Union{Tuple{Array{#s18,1} where #s18&lt;:Array{T,1}}, Tuple{T}} where T"><code>build</code></a> předat jako argument.</p><p>Funkce poté prochází jednotlivá pole tokenů, vždy zkoumá<span>$k$</span>-tici tokenů v jednom poli — ta tvoří stav. Tento stav bude klíčem ve slovníku <code>nodes</code> — všechny klíče tohoto slovníku tvoří kompletní stavový prostor Markovova řetězce. Hodnota pod tímto klíčem bude další slovník, konkrétně slovník <code>TokenOccurences</code> párující vždy token a číslo představující počet, kolikrát se tento token za daným stavem vyskytl (&gt;=1).</p><p>Ještě před touto analýzou tokenů je nutné doplnit některé tokeny pomocné, konkrétně symboly <code>:begin</code> a <code>:end</code>, které vyznačují začátek a konec &quot;věty&quot; (tedy jednoho z dílčích polí). Každé pole tedy bude vypadat takto: <code>[:begin :begin ... :begin token token ... token :end]</code>.</p><ul><li><p>Účel symbolu <code>:end</code> je jednoduchý: ukončuje náhodné procházení modelu ve funkci <a href="../public/#MarkovChains.walk-Tuple{Any}"><code>walk</code></a>.</p></li><li><p>Počet symbolů <code>:begin</code> na začátku pole je roven řádu celého řetězce. To je nutné proto, abych nemusel ukládat počáteční stavy do speciální proměnné. Klíče i hodnoty slovníku by totiž měly mít všechny stejný typ.</p></li></ul><p>Původně měla struktura <code>Model</code> ještě jedno pole, které bylo speciálně vyhrazené pro počáteční stavy (a <code>:begin</code> nebylo používáno). Nastal by pak ale drobný problém, kdyby uživatel chtěl využít externí balíček pro ukládání do souboru JSON, protože <code>Model</code> by byl reprezentován dvěma slovníky a bylo by nutné toto při ukládání ošeřit. Uchýlil jsem se proto v pozdějších verzích k tomuto jednoslovníkovému řešení; uživateli teď stačí uložit do souboru pouze slovník <code>nodes</code> a využít funkci <a href="../public/#MarkovChains.makefromdict-Tuple{Any}"><code>makefromdict</code></a> k opětovné rekonstrukci modelu.</p><p>Místo symbolu <code>:begin</code> byl využíván v dřívějších verzích přímo string <code>&quot;~~BEGIN~~&quot;</code>. Pokud by však uživatel z nějakého důvodu toto slovo měl ve vstupním textu, byl by klidně i prostředek věty omylem pokládán za počáteční stav. Z toho důvodu nakonec používám datový typ <code>Symbol</code>, který je podobný symbolům v LISP.</p><h2><a class="nav-anchor" id="Procházení-modelového-grafu-1" href="#Procházení-modelového-grafu-1">Procházení modelového grafu</a></h2><p>K procházení grafu a generování náhodného textu slouží funkce <a href="../public/#MarkovChains.walk-Tuple{Any}"><code>walk</code></a> a <a href="../public/#MarkovChains.walk2-Tuple{Any}"><code>walk2</code></a>. Z modelu získjí jeho slovník všech stavů, <code>nodes</code>. Generování začne ve stavu <code>[:begin :begin ... :begin]</code> a poté postupuje po krocích dále (&quot;krok&quot; viz níže). Jakmile narazí na token <code>:end</code>, vrátí vybudované pole tokenů.</p><p>Co je krok:</p><ol><li>Nacházíme se v nějakém stavu.</li><li>Koukneme se do slovníku <code>nodes</code> na všechny možné tokeny, které následují po současném stavu.</li><li>Vybereme jeden z nich. Způsob výběru je náhodný, řídí se ale relativními četnostmi jednotlivých tokenů za daným stavem. Pokud je <code>nodes[současný_stav]</code> rovno <code>Dict(A =&gt; 2, B =&gt; 1)</code>, je šance, že zvolený token bude A, dvakrát vyšší, než že to bude B.</li><li>Vybraný token zařadíme za současný stav (který je jen polem tokenů) a odstraníme z něj zároveň token, který je na začátku. Toto označíme jako nový stav (má stejnou délku jako ten starý) a jdeme na bod 1.</li></ol><p>Jak funguje pseudonáhodný výběr ze slovníku:</p><ol><li>Uděláme postupný součet všech četností jednotlivých tokenů. Tj, pro <code>Dict(A =&gt; 2, B =&gt; 1, C =&gt; 5)</code> bychom vytvořili pole <code>[2, 3, 8]</code>.</li><li>Vygenerujeme náhodné číslo v rozmezí od nuly do nejvyššího čísla tohoto pole a pokusíme se ho zařadit do tohoto pole tak, aby pole zůstalo seřazené. Pravděpodobnost výběru daného čísla je tak v poměru k jeho četnosti.</li><li>Index, na který bychom číslo umístili, použijeme jako index následujícího tokenu.</li></ol><footer><hr/><a class="previous" href="../function/"><span class="direction">Previous</span><span class="title">Princip</span></a><a class="next" href="../lipsum/"><span class="direction">Next</span><span class="title">Lorem ipsum</span></a></footer></article></body></html>
