<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interní symboly (EN) · MarkovChains.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="MarkovChains.jl logo"/></a><h1>MarkovChains.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Domovská stránka</a></li><li><span class="toctext">Vysvětlení</span><ul><li><a class="toctext" href="../function/">Popis funkce</a></li><li><a class="toctext" href="../implementation/">Popis implementace</a></li></ul></li><li><span class="toctext">Knihovna</span><ul><li><a class="toctext" href="../public/">Veřejné symboly (EN)</a></li><li class="current"><a class="toctext" href>Interní symboly (EN)</a><ul class="internal"></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Knihovna</li><li><a href>Interní symboly (EN)</a></li></ul><a class="edit-page" href="https://github.com/Eugleo/MarkovChains.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Interní symboly (EN)</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Internal-Documentation-1" href="#Internal-Documentation-1">Internal Documentation</a></h1><p>The following are the private symbols from the module <code>MarkdownChains</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.build-Tuple{Array{Array{Any,1},1}}" href="#MarkovChains.build-Tuple{Array{Array{Any,1},1}}"><code>MarkovChains.build</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">build(suptokens::Vector{Vector{Token{T}}}; order=2, weight=stdweight)</code></pre><p>Trains a Markov chain on an array of arrays of tokens (suptokens). Optionally an <code>order</code> of the chain can be supplied, that is the number of tokens in one state. A weight function of general type <code>func(s::State{T}, t::Token{T})::Int</code> can be supplied to be used to bias the weights based on the state or token.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L77-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.combine-Tuple{MarkovChains.Model,Vararg{MarkovChains.Model,N} where N}" href="#MarkovChains.combine-Tuple{MarkovChains.Model,Vararg{MarkovChains.Model,N} where N}"><code>MarkovChains.combine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">function combine(chain::Model, others::Model...)</code></pre><p>Return a Model which is a combination of all of the models provided. All of the arguments should have the same <code>order</code>. The nodes of all the Models are merged using the function <code>merge</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L45-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.state_with_beginning-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T" href="#MarkovChains.state_with_beginning-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T"><code>MarkovChains.state_with_beginning</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">state_with_beginning(model::Model{T}, tokens::Vector{Token{T}}; strict=false) where T</code></pre><p>Attempts to return a random valid state of <code>model</code> that begins with <code>tokens</code>. If <code>strict</code> is <code>false</code> and the <code>model</code> doesn&#39;t have any state that begins with <code>tokens</code>, the function shortens the tokens (cuts the last token) to lower the requirements and tries to find some valid state again.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L248-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk-Tuple{MarkovChains.Model{Any}}" href="#MarkovChains.walk-Tuple{MarkovChains.Model{Any}}"><code>MarkovChains.walk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk(model::Model)</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. The walk starts at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) and ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk2-Tuple{MarkovChains.Model{Any}}"><code>walk2</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L108-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T" href="#MarkovChains.walk-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T"><code>MarkovChains.walk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk(model::Model{T}[, init_state::State{T}]) where T</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. The walk starts at state <code>init_state</code> and ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk2-Tuple{MarkovChains.Model{Any}}"><code>walk2</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L122-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk2-Tuple{MarkovChains.Model{Any}}" href="#MarkovChains.walk2-Tuple{MarkovChains.Model{Any}}"><code>MarkovChains.walk2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk2(model::Model{Any})</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. When there is only one state following the current one (i.e. there is 100% chance that the state will become the next one), the function shortens the current <code>State</code> as to lower the requirements and obtain more randomness. The <code>State</code> gets shortened until a state with at least two possible successors is found (or until <code>State</code> is only one token long).</p><p>The walk starts at state <code>[:begin, :begin...]</code> (the length depends on the order of the supplied <code>model</code>) and ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk-Tuple{MarkovChains.Model{Any}}"><code>walk</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L162-L177">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walk2-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T" href="#MarkovChains.walk2-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T"><code>MarkovChains.walk2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walk2(model::Model{T}[, init_state::State{T}]) where T</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. When there is only one state following the current one (i.e. there is 100% chance that the state will become the next one), the function shortens the current <code>State</code> as to lower the requirements and obtain more randomness. The <code>State</code> gets shortened until a state with at least two possible successors is found (or until <code>State</code> is only one token long).</p><p>The walk starts at state <code>init_state</code> and ends once a special token <code>:end</code> is reached.</p><p>See also: <a href="#MarkovChains.walk-Tuple{MarkovChains.Model{Any}}"><code>walk</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L188-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.Model" href="#MarkovChains.Model"><code>MarkovChains.Model</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The datastructure of the Markov chain. Encodes all the different states and the probabilities of going from one to another as a dictionary. The keys are the states, the values are the respective <a href="#MarkovChains.TokenOccurences"><code>TokenOccurences</code></a> dictionaries. Those are dictionaries which say how many times was a token found <em>immediately</em> after the state.</p><p><strong>Fields</strong></p><ul><li><code>order</code> is the number of tokens the <a href="#MarkovChains.State"><code>State</code></a></li><li><code>nodes</code> is a dictionary pairing <a href="#MarkovChains.State"><code>State</code></a> and its respective</li></ul><p><a href="#MarkovChains.TokenOccurences"><code>TokenOccurences</code></a> dictionary.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L28-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.State" href="#MarkovChains.State"><code>MarkovChains.State</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">State{T} = Vector{Token{T}}</code></pre><p>A state is a succession of tokens.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.TokenOccurences" href="#MarkovChains.TokenOccurences"><code>MarkovChains.TokenOccurences</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">TokenOccurences{Token} = Dict{Union{Token, Symbol}, Int}</code></pre><p>A dictionary pairing tokens (or special symbols <code>:begin</code> and <code>:end</code>) with the number of their respective occurences.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L20-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.append_token-Union{Tuple{T}, Tuple{Array{Union{Symbol, T},1},Union{Symbol, T}}} where T" href="#MarkovChains.append_token-Union{Tuple{T}, Tuple{Array{Union{Symbol, T},1},Union{Symbol, T}}} where T"><code>MarkovChains.append_token</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">append_token(state::State{T}, token::Token{T}) where T</code></pre><p>Drop the first element in <code>state</code> and append the <code>token</code> at the end of the <code>state</code> array.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L213-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.begseq-Tuple{Any}" href="#MarkovChains.begseq-Tuple{Any}"><code>MarkovChains.begseq</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">begseq(n)</code></pre><p>Return the symbol <code>:begin</code> repeated <code>n</code> times. This array is then used as a starting sequence for all suptokens.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L58-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.indexof-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T" href="#MarkovChains.indexof-Union{Tuple{T}, Tuple{AbstractArray{T,1},T}} where T"><code>MarkovChains.indexof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">indexof(array::AbstractVector{T}, n::T) where T</code></pre><p>Given a sorted <code>array</code>, return the index on which <code>n</code> would be inserted in should the insertion preserve the sorting.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L327-L332">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.next_token-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T" href="#MarkovChains.next_token-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1}}} where T"><code>MarkovChains.next_token</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">next_token(model::Model{T}, state::State{T}) where T</code></pre><p>Return a token which will come after the current state, at random. The probabilities of individual tokens getting choosed are skewed by their individual values in the <code>TokenOccurences</code> dictionary of the current <code>state</code>, that is obtained from the <code>model</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L296-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.randkey-Tuple{AbstractDict{Any,Number}}" href="#MarkovChains.randkey-Tuple{AbstractDict{Any,Number}}"><code>MarkovChains.randkey</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">randkey(dict::AbstractDict{Any, Number})</code></pre><p>Return a random key from <code>dict</code>. The probabilities of individual keys getting chosen are skewed by their respective values.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L309-L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.states_with_suffix-Union{Tuple{T}, Tuple{Model{T},Array{T,1}}} where T" href="#MarkovChains.states_with_suffix-Union{Tuple{T}, Tuple{Model{T},Array{T,1}}} where T"><code>MarkovChains.states_with_suffix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">states_with_suffix(model::Model{T}, init_suffix::Vector{Tokens{T}}) where T</code></pre><p>Return all of the states of <code>model</code> that end with <code>init_suffix</code>. If the number of such states is 1 (or 0), the function shortens the suffix (cuts the first token) in order to lower the requirements, and makes another try.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L135-L141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.stdweight-Union{Tuple{T}, Tuple{Array{Union{Symbol, T},1},Union{Symbol, T}}} where T" href="#MarkovChains.stdweight-Union{Tuple{T}, Tuple{Array{Union{Symbol, T},1},Union{Symbol, T}}} where T"><code>MarkovChains.stdweight</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stdweight(state::State{T}, token::Token{T}) where T</code></pre><p>A constant <code>1</code>. Used as a placeholder function in <a href="#MarkovChains.build-Tuple{Array{Array{Any,1},1}}"><code>build</code></a> to represent unbiased weight function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L67-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MarkovChains.walker-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1},Any}, Tuple{Model{T},Array{Union{Symbol, T},1},Any,Any}} where T" href="#MarkovChains.walker-Union{Tuple{T}, Tuple{Model{T},Array{Union{Symbol, T},1},Any}, Tuple{Model{T},Array{Union{Symbol, T},1},Any,Any}} where T"><code>MarkovChains.walker</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">walker(model::Model{T}, init_state::State{T}, init_accum, newstate=append_token) where T</code></pre><p>Return an array of tokens obtained by a random walk through the Markov chain. The walk starts at state <code>init_state</code> and ends once a special token <code>:end</code> is reached. A function <code>newstate</code> of general type <code>func(state::State{T}, token::Token{T})::State{T} where T</code> can be supplied to be used to generate a new state given the old state and the following token.</p><p>This is a general function which is used by all the <code>walk</code> functions.</p><p>See also: <a href="#MarkovChains.walk-Tuple{MarkovChains.Model{Any}}"><code>walk</code></a>, <a href="#MarkovChains.walk2-Tuple{MarkovChains.Model{Any}}"><code>walk2</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/MarkovChains.jl#L223-L235">source</a></section><p>The following are the private symbols from the module <code>Tokenizer</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.cleanup-Tuple{Array{Array{String,1},1}}" href="#Tokenizer.cleanup-Tuple{Array{Array{String,1},1}}"><code>Tokenizer.cleanup</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">cleanup(suptokens::Vector{Vector{String}}; badchars=&quot;</code></pre><p>-_()[]{}&lt;&gt;–—$=&#39;&quot;„“ 	&quot;)</p><p>Remove all characters that are in <code>badchars</code> from all tokens in <code>suptokens</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L74-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.letters" href="#Tokenizer.letters"><code>Tokenizer.letters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">letters = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into sentences, then the sentences into letters, and then removes special characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L90-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.lines" href="#Tokenizer.lines"><code>Tokenizer.lines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lines = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into lines, then the line into letters, and then removes special characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L98-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_letters-Tuple{Array{String,1}}" href="#Tokenizer.to_letters-Tuple{Array{String,1}}"><code>Tokenizer.to_letters</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_letters(tokens::Vector{String})</code></pre><p>Split all of the tokens in <code>tokens</code> into individual characters.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L53-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_lines-Tuple{Any}" href="#Tokenizer.to_lines-Tuple{Any}"><code>Tokenizer.to_lines</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_lines(text)</code></pre><p>Return an array of lines in <code>text</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_sentences-Tuple{Any}" href="#Tokenizer.to_sentences-Tuple{Any}"><code>Tokenizer.to_sentences</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_sentences(text)</code></pre><p>Return an array of sentences in <code>text</code>. The text is split along dots; the dots remain in the strings, only the spaces after the dots are stripped.</p><p>The function tries to be as smart as possible. For example, the string <code>&quot;Channel No. 5 is a perfume.&quot;</code> will be treated as one sentence, although it has two dots.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L36-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.tokenize" href="#Tokenizer.tokenize"><code>Tokenizer.tokenize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tokenize(inp[, func=letters])</code></pre><p>Split the text into SupTokens (list of lists of tokens). An optional function of general type <code>func(inp:T1)::Vector{Vector{T2}}</code> can be provided to be used for the tokenization.</p><p>For possible <em>combinators</em> which can be composed to obtain <code>func</code>, see: <a href="#Tokenizer.to_lines-Tuple{Any}"><code>to_lines</code></a>, <a href="#Tokenizer.to_sentences-Tuple{Any}"><code>to_sentences</code></a>, <a href="#Tokenizer.to_letters-Tuple{Array{String,1}}"><code>to_letters</code></a>, <a href="#Tokenizer.to_words-Tuple{Array{String,1}}"><code>to_words</code></a>, <a href="#Tokenizer.cleanup-Tuple{Array{Array{String,1},1}}"><code>cleanup</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L12-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.words" href="#Tokenizer.words"><code>Tokenizer.words</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">words = cleanup ∘ to_letters ∘ to_sentences</code></pre><p>Composite function which splits its input into sentences, then the sentences into words, and then removes special characters. Please note that dots and commas are not removed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L106-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Tokenizer.to_words-Tuple{Array{String,1}}" href="#Tokenizer.to_words-Tuple{Array{String,1}}"><code>Tokenizer.to_words</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">to_words(tokens::Vector{String}; keeppunctuation=true)</code></pre><p>Split all of the tokens in <code>tokens</code> into individual words by whitespace. If <code>keeppunctuation</code> is true, all of the special characters are preserved (and thus &quot;glued&quot; to the preceding/following word).</p></div></div><a class="source-link" target="_blank" href="https://github.com/Eugleo/MarkovChains.jl/blob/e49e4bfc4f7192be4140c169dac7cb83ea9576bb/src/Tokenizer.jl#L62-L68">source</a></section><footer><hr/><a class="previous" href="../public/"><span class="direction">Previous</span><span class="title">Veřejné symboly (EN)</span></a></footer></article></body></html>
